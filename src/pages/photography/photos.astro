---
import PhotoLayout from '../../layouts/PhotoLayout.astro';
import {
  getAlbumTitleMap,
  getPhotosWithExif,
  sortPhotos,
  parseSettings,
  extractTags,
  extractTagNames,
  formatShutterSpeed,
  transformForLightbox
} from '../../utils/photo-helpers';
import { getCollection } from 'astro:content';
import { getPhotoUrl, getResizedPhotoUrl } from '../../utils/url-helper';
import PhotoLightbox from '../../components/photo/PhotoLightbox.astro';
import PhotoIcons from '../../components/photo/PhotoIcons.astro';
import ViewfinderSVG from '../../components/photo/ViewfinderSVG.astro';

// Get all photos with EXIF data
const allPhotos = await getPhotosWithExif();

// Sort by order_score (highest first), then by date descending
const sortedPhotos = sortPhotos(allPhotos);

// Get all albums for filter
const albums = await getCollection('albums');
const sortedAlbums = albums.sort((a, b) => a.data.title.localeCompare(b.data.title));
const albumTitleMap = await getAlbumTitleMap(albums);

// Extract unique tags with photo counts (sorted by count, then alphabetically)
const tagsWithCounts = extractTags(allPhotos, { sortBy: 'count' });
const uniqueTags = tagsWithCounts.map(t => t.tag);
const tagCountsObj = Object.fromEntries(tagsWithCounts.map(t => [t.tag, t.count]));

// Extract unique cameras
const allCameras = new Set<string>();
allPhotos.forEach(photo => {
  if (photo.data.camera) allCameras.add(photo.data.camera);
});
const uniqueCameras = Array.from(allCameras).sort();

// Parse EXIF ranges
interface ExifRanges {
  aperture: { min: number; max: number };
  shutterSpeed: { min: number; max: number };
  iso: { min: number; max: number };
  focalLength: { min: number; max: number };
  date: { min: Date; max: Date };
}

function getDecimalPlaces(step: number): number {
  if (!Number.isFinite(step) || step <= 0) {
    return 0;
  }

  const stepString = step.toString();
  if (stepString.includes('e-')) {
    const [, exponent] = stepString.split('e-');
    return parseInt(exponent || '0', 10);
  }

  const decimalSegment = stepString.split('.')[1];
  return decimalSegment ? decimalSegment.length : 0;
}

function alignRangeToStep(range: { min: number; max: number }, step: number): { min: number; max: number } {
  if (!Number.isFinite(range.min) || !Number.isFinite(range.max) || step <= 0) {
    return range;
  }

  const decimals = getDecimalPlaces(step);
  const minAligned = Number((Math.floor(range.min / step) * step).toFixed(decimals));
  const maxAligned = Number((Math.ceil(range.max / step) * step).toFixed(decimals));

  return {
    min: minAligned,
    max: Math.max(maxAligned, minAligned)
  };
}

const exifRanges: ExifRanges = {
  aperture: { min: Infinity, max: -Infinity },
  shutterSpeed: { min: Infinity, max: -Infinity },
  iso: { min: Infinity, max: -Infinity },
  focalLength: { min: Infinity, max: -Infinity },
  date: { min: new Date(8640000000000000), max: new Date(-8640000000000000) }
};

allPhotos.forEach(photo => {
  const parsed = parseSettings(photo.data.settings);

  if (parsed.aperture !== undefined) {
    exifRanges.aperture.min = Math.min(exifRanges.aperture.min, parsed.aperture);
    exifRanges.aperture.max = Math.max(exifRanges.aperture.max, parsed.aperture);
  }

  if (parsed.shutterSpeed !== undefined) {
    exifRanges.shutterSpeed.min = Math.min(exifRanges.shutterSpeed.min, parsed.shutterSpeed);
    exifRanges.shutterSpeed.max = Math.max(exifRanges.shutterSpeed.max, parsed.shutterSpeed);
  }

  if (parsed.iso !== undefined) {
    exifRanges.iso.min = Math.min(exifRanges.iso.min, parsed.iso);
    exifRanges.iso.max = Math.max(exifRanges.iso.max, parsed.iso);
  }

  if (photo.data.focalLength !== undefined) {
    exifRanges.focalLength.min = Math.floor(Math.min(exifRanges.focalLength.min, photo.data.focalLength));
    exifRanges.focalLength.max = Math.ceil(Math.max(exifRanges.focalLength.max, photo.data.focalLength));
  }

  if (photo.data.date) {
    exifRanges.date.min = new Date(Math.min(exifRanges.date.min.getTime(), photo.data.date.getTime()));
    exifRanges.date.max = new Date(Math.max(exifRanges.date.max.getTime(), photo.data.date.getTime()));
  }
});

// Handle infinity values (no data available)
if (!Number.isFinite(exifRanges.aperture.min)) {
  exifRanges.aperture = { min: 1.4, max: 22 };
}
if (!Number.isFinite(exifRanges.shutterSpeed.min)) {
  exifRanges.shutterSpeed = { min: 0.0001, max: 30 };
}
if (!Number.isFinite(exifRanges.iso.min)) {
  exifRanges.iso = { min: 100, max: 12800 };
}
if (!Number.isFinite(exifRanges.focalLength.min)) {
  exifRanges.focalLength = { min: 10, max: 600 };
}

// Ensure max is at least min
if (exifRanges.focalLength.max < exifRanges.focalLength.min) {
  exifRanges.focalLength.max = exifRanges.focalLength.min;
}

const RANGE_STEPS = {
  aperture: 0.1,
  shutterSpeed: 0.0001,
  iso: 100,
  focalLength: 1,
};

exifRanges.aperture = alignRangeToStep(exifRanges.aperture, RANGE_STEPS.aperture);
exifRanges.shutterSpeed = alignRangeToStep(exifRanges.shutterSpeed, RANGE_STEPS.shutterSpeed);
exifRanges.iso = alignRangeToStep(exifRanges.iso, RANGE_STEPS.iso);
exifRanges.focalLength = alignRangeToStep(exifRanges.focalLength, RANGE_STEPS.focalLength);

---

<PhotoLayout title="All Photos" description="Browse all photos with advanced filters">
  <PhotoIcons />

  <div class="photos-page">
    <div class="page-header">
      <h1 class="page-title">All Photos</h1>
      <p class="page-subtitle">{sortedPhotos.length} photos · Advanced filtering</p>
      <button id="toggle-filters" class="toggle-filters-btn" aria-label="Toggle filters">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M22 3H2l8 9.46V19l4 2v-8.54L22 3z"/>
        </svg>
        <span>Filters</span>
        <span id="filter-count" class="filter-count" style="display: none;">0</span>
      </button>
    </div>

    <div class="content-wrapper">
      <!-- Filter Panel -->
      <aside id="filter-panel" class="filter-panel">
        <div class="filter-panel-header">
          <h2 class="filter-panel-title">Filters</h2>
          <div class="filter-header-actions">
            <button id="clear-filters" class="clear-filters-btn">Clear All</button>
            <button id="close-filters" class="close-filters-btn" aria-label="Close filters">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>
        </div>

        <div class="filter-sections">
          <!-- Tags Filter -->
          <div class="filter-section">
            <div class="filter-section-header">
              <h3 class="filter-section-title">Tags</h3>
              <div class="tag-logic-toggle" id="tag-logic-toggle" role="group" aria-label="Tag filter mode">
                <button
                  type="button"
                  class="toggle-option"
                  data-mode="or"
                  id="toggle-or"
                  aria-pressed="true"
                >
                  OR
                </button>
                <button
                  type="button"
                  class="toggle-option"
                  data-mode="and"
                  id="toggle-and"
                  aria-pressed="false"
                >
                  AND
                </button>
              </div>
            </div>
            <div class="tag-search-wrapper">
              <input
                type="text"
                id="tag-search"
                class="tag-search-input"
                placeholder="Search tags..."
                autocomplete="off"
              />
              <svg class="tag-search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
              </svg>
            </div>
            <div id="tags-filter" class="filter-checkboxes">
              {uniqueTags.map(tag => (
                <label class="filter-checkbox-label" data-tag={tag}>
                  <input type="checkbox" name="tag" value={tag} />
                  <span class="tag-name">#{tag}</span>
                  <span class="tag-count">({tagCountsObj[tag]})</span>
                </label>
              ))}
            </div>
          </div>

          <!-- Albums Filter -->
          <div class="filter-section">
            <h3 class="filter-section-title">Albums</h3>
            <div id="albums-filter" class="filter-checkboxes">
              {sortedAlbums.map(album => (
                <label class="filter-checkbox-label">
                  <input type="checkbox" name="album" value={album.slug} />
                  <span>{album.data.title}</span>
                </label>
              ))}
            </div>
          </div>

          <!-- Date Range Filter -->
          <div class="filter-section">
            <h3 class="filter-section-title">Date Range</h3>
            <div class="filter-range-inputs">
              <div class="filter-input-group">
                <label for="date-min">From</label>
                <input
                  type="date"
                  id="date-min"
                  name="date-min"
                  value={exifRanges.date.min.toISOString().split('T')[0]}
                  min={exifRanges.date.min.toISOString().split('T')[0]}
                  max={exifRanges.date.max.toISOString().split('T')[0]}
                />
              </div>
              <div class="filter-input-group">
                <label for="date-max">To</label>
                <input
                  type="date"
                  id="date-max"
                  name="date-max"
                  value={exifRanges.date.max.toISOString().split('T')[0]}
                  min={exifRanges.date.min.toISOString().split('T')[0]}
                  max={exifRanges.date.max.toISOString().split('T')[0]}
                />
              </div>
            </div>
          </div>

          <!-- Camera Filter -->
          <div class="filter-section">
            <h3 class="filter-section-title">Camera</h3>
            <div id="cameras-filter" class="filter-checkboxes">
              {uniqueCameras.map(camera => (
                <label class="filter-checkbox-label">
                  <input type="checkbox" name="camera" value={camera} />
                  <span>{camera}</span>
                </label>
              ))}
            </div>
          </div>

          <!-- Aperture Filter -->
          <div class="filter-section">
            <h3 class="filter-section-title">Aperture (f-stop)</h3>
            <div class="filter-range-group">
              <div class="filter-range-slider">
                <input
                  type="range"
                  id="aperture-min"
                  min={exifRanges.aperture.min}
                  max={exifRanges.aperture.max}
                  step="0.1"
                  value={exifRanges.aperture.min}
                />
                <input
                  type="range"
                  id="aperture-max"
                  min={exifRanges.aperture.min}
                  max={exifRanges.aperture.max}
                  step="0.1"
                  value={exifRanges.aperture.max}
                />
              </div>
              <div class="filter-range-values">
                <span id="aperture-min-value">f/{exifRanges.aperture.min}</span>
                <span>—</span>
                <span id="aperture-max-value">f/{exifRanges.aperture.max}</span>
              </div>
            </div>
          </div>

          <!-- Shutter Speed Filter -->
          <div class="filter-section">
            <h3 class="filter-section-title">Shutter Speed</h3>
            <div class="filter-range-group">
              <div class="filter-range-slider">
                <input
                  type="range"
                  id="shutter-min"
                  min={exifRanges.shutterSpeed.min}
                  max={exifRanges.shutterSpeed.max}
                  step="0.0001"
                  value={exifRanges.shutterSpeed.min}
                />
                <input
                  type="range"
                  id="shutter-max"
                  min={exifRanges.shutterSpeed.min}
                  max={exifRanges.shutterSpeed.max}
                  step="0.0001"
                  value={exifRanges.shutterSpeed.max}
                />
              </div>
              <div class="filter-range-values">
                <span id="shutter-min-value">{formatShutterSpeed(exifRanges.shutterSpeed.min)}</span>
                <span>—</span>
                <span id="shutter-max-value">{formatShutterSpeed(exifRanges.shutterSpeed.max)}</span>
              </div>
            </div>
          </div>

          <!-- ISO Filter -->
          <div class="filter-section">
            <h3 class="filter-section-title">ISO</h3>
            <div class="filter-range-group">
              <div class="filter-range-slider">
                <input
                  type="range"
                  id="iso-min"
                  min={exifRanges.iso.min}
                  max={exifRanges.iso.max}
                  step="100"
                  value={exifRanges.iso.min}
                />
                <input
                  type="range"
                  id="iso-max"
                  min={exifRanges.iso.min}
                  max={exifRanges.iso.max}
                  step="100"
                  value={exifRanges.iso.max}
                />
              </div>
              <div class="filter-range-values">
                <span id="iso-min-value">{exifRanges.iso.min}</span>
                <span>—</span>
                <span id="iso-max-value">{exifRanges.iso.max}</span>
              </div>
            </div>
          </div>

          <!-- Focal Length Filter -->
          <div class="filter-section">
            <h3 class="filter-section-title">Focal Length (mm)</h3>
            <div class="filter-range-group">
              <div class="filter-range-slider">
                <input
                  type="range"
                  id="focal-min"
                  min={exifRanges.focalLength.min}
                  max={exifRanges.focalLength.max}
                  step="1"
                  value={exifRanges.focalLength.min}
                />
                <input
                  type="range"
                  id="focal-max"
                  min={exifRanges.focalLength.min}
                  max={exifRanges.focalLength.max}
                  step="1"
                  value={exifRanges.focalLength.max}
                />
              </div>
              <div class="filter-range-values">
                <span id="focal-min-value">{Math.round(exifRanges.focalLength.min)}mm</span>
                <span>—</span>
                <span id="focal-max-value">{Math.round(exifRanges.focalLength.max)}mm</span>
              </div>
            </div>
          </div>
        </div>
      </aside>

      <!-- Photos Grid -->
      <main class="photos-main">
        <div id="photos-status" class="photos-status">
          <span id="visible-count">{Math.min(20, sortedPhotos.length)}</span> of <span id="total-count">{sortedPhotos.length}</span> photos
        </div>

        <div id="photos-grid" class="photos-grid">
          <!-- Photos will be rendered progressively by JavaScript -->
        </div>

        <template id="viewfinder-template">
          <div class="viewfinder-overlay">
            <ViewfinderSVG />
          </div>
        </template>

        <div id="loading-indicator" class="loading-indicator" style="display: none;">
          <div class="loading-spinner"></div>
          <p>Loading more photos...</p>
        </div>

        <div id="no-results" class="no-results" style="display: none;">
          <p>No photos match your filters.</p>
          <button id="reset-filters" class="reset-filters-btn">Reset Filters</button>
        </div>
      </main>
    </div>
  </div>

  <PhotoLightbox photos={sortedPhotos.map(p => transformForLightbox(p, albumTitleMap))} />

  <script>
    import { filterPhotosByTags, getAvailableTags, normalizeTag, setupTagLogicToggle } from '../../utils/client/tag-utils';
    import { formatShutterSpeed } from '../../utils/shared/exif';
    (window as any).photoTagUtils = { filterPhotosByTags, getAvailableTags, normalizeTag, setupTagLogicToggle };
    (window as any).photoFormatters = { formatShutterSpeed };
  </script>

  <script define:vars={{
    allPhotosData: sortedPhotos.map(p => ({
      id: p.id,
      url: getPhotoUrl(p.data.filename),
      resizedUrl: getResizedPhotoUrl(p.data.filename, 600),
      body: p.body || '',
      data: {
        title: p.data.title,
        filename: p.data.filename,
        album: p.data.album,
        albumTitle: albumTitleMap.get(p.data.album),
        tags: (p.data.tags || []).map(t => (t || '').trim()).filter(t => t),
        camera: p.data.camera,
        settings: p.data.settings,
        focalLength: p.data.focalLength,
        location: p.data.location,
        date: p.data.date.toISOString(),
        position: p.data.position
      }
    })),
    exifRangesData: {
      aperture: { min: exifRanges.aperture.min, max: exifRanges.aperture.max },
      shutterSpeed: { min: exifRanges.shutterSpeed.min, max: exifRanges.shutterSpeed.max },
      iso: { min: exifRanges.iso.min, max: exifRanges.iso.max },
      focalLength: { min: exifRanges.focalLength.min, max: exifRanges.focalLength.max },
      date: {
        min: exifRanges.date.min.toISOString(),
        max: exifRanges.date.max.toISOString()
      }
    }
  }}>
    const normalizeTag =
      (window.photoTagUtils && window.photoTagUtils.normalizeTag) ||
      ((tag) => String(tag ?? '').toLowerCase().trim());

    const filterPhotosByTags =
      (window.photoTagUtils && window.photoTagUtils.filterPhotosByTags) ||
      ((photos, tags, logic = 'or') => {
        if (tags.length === 0) return photos;

        return photos.filter(photo => {
          const photoTags = (photo.data?.tags || []).map(t => normalizeTag(t)).filter(Boolean);
          if (logic === 'and') {
            return tags.every(tag => photoTags.includes(normalizeTag(tag)));
          }
          return tags.some(tag => photoTags.includes(normalizeTag(tag)));
        });
      });

    const getAvailableTags =
      (window.photoTagUtils && window.photoTagUtils.getAvailableTags) ||
      ((photos, selectedTags, logic) => {
        if (logic === 'or') {
          const allTags = new Set();
          photos.forEach(photo => {
            (photo.data?.tags || []).forEach(tag => {
              const normalized = normalizeTag(tag);
              if (normalized) allTags.add(normalized);
            });
          });
          return allTags;
        }

        const filtered = filterPhotosByTags(photos, selectedTags, 'and');
        const available = new Set();

        filtered.forEach(photo => {
          (photo.data?.tags || []).forEach(tag => {
            const normalized = normalizeTag(tag);
            if (normalized) available.add(normalized);
          });
        });

        selectedTags.forEach(tag => available.add(normalizeTag(tag)));
        return available;
      });

    const setupTagLogicToggle =
      (window.photoTagUtils && window.photoTagUtils.setupTagLogicToggle) ||
      ((toggleContainer, onModeChange) => {
        if (!toggleContainer) return;
        const buttons = toggleContainer.querySelectorAll('.toggle-option');
        buttons.forEach(button => {
          button.addEventListener('click', () => {
            const mode = button.dataset.mode === 'and' ? 'and' : 'or';
            buttons.forEach(btn => {
              btn.setAttribute('aria-pressed', btn.dataset.mode === mode ? 'true' : 'false');
            });
            onModeChange(mode);
          });
        });
      });

    const formatShutterSpeed =
      (window.photoFormatters && window.photoFormatters.formatShutterSpeed) ||
      ((seconds) => {
        if (seconds < 1) {
          const denominator = Math.round(1 / seconds);
          return `1/${denominator}s`;
        }
        return `${seconds.toFixed(1)}s`;
      });

    // Photo filtering and progressive loading
    const BATCH_SIZE = 20;
    console.log('EXIF Ranges:', exifRangesData);
    let currentBatchIndex = 0;
    let filteredPhotos = [...allPhotosData];
    let displayedPhotos = [];
    const viewfinderTemplate = document.getElementById('viewfinder-template');
    const viewfinderMarkup = viewfinderTemplate?.innerHTML?.trim?.() || '';

    // Parse settings helper
    function parseSettings(settings) {
      if (!settings) return {};

      const result = {};

      const apertureMatch = settings.match(/f\/([\d.]+)/);
      if (apertureMatch) {
        result.aperture = parseFloat(apertureMatch[1]);
      }

      const shutterMatch = settings.match(/(\d+)\/(\d+)s|(\d+(?:\.\d+)?)s/);
      if (shutterMatch) {
        if (shutterMatch[1] && shutterMatch[2]) {
          result.shutterSpeed = parseInt(shutterMatch[1]) / parseInt(shutterMatch[2]);
        } else if (shutterMatch[3]) {
          result.shutterSpeed = parseFloat(shutterMatch[3]);
        }
      }

      const isoMatch = settings.match(/ISO\s*(\d+)/);
      if (isoMatch) {
        result.iso = parseInt(isoMatch[1]);
      }

      return result;
    }

    // Get current filter state
    function getFilterState() {
      const tags = Array.from(document.querySelectorAll('input[name="tag"]:checked'))
        .map(el => normalizeTag(el.value))
        .filter(t => t);

      // Get tag logic mode (AND or OR)
      const activeToggle = document.querySelector('.tag-logic-toggle .toggle-option[aria-pressed="true"]');
      const tagLogic = activeToggle?.getAttribute('data-mode') || 'or';

      const albums = Array.from(document.querySelectorAll('input[name="album"]:checked'))
        .map(el => el.value);

      const cameras = Array.from(document.querySelectorAll('input[name="camera"]:checked'))
        .map(el => el.value);

      const dateMin = new Date(document.getElementById('date-min').value);
      const dateMax = new Date(document.getElementById('date-max').value);
      dateMax.setHours(23, 59, 59, 999); // Include entire last day

      const apertureMin = parseFloat(document.getElementById('aperture-min').value);
      const apertureMax = parseFloat(document.getElementById('aperture-max').value);

      const shutterMin = parseFloat(document.getElementById('shutter-min').value);
      const shutterMax = parseFloat(document.getElementById('shutter-max').value);

      const isoMin = parseInt(document.getElementById('iso-min').value);
      const isoMax = parseInt(document.getElementById('iso-max').value);

      const focalMin = parseInt(document.getElementById('focal-min').value);
      const focalMax = parseInt(document.getElementById('focal-max').value);

      return {
        tags,
        tagLogic,
        albums,
        cameras,
        dateMin,
        dateMax,
        apertureMin,
        apertureMax,
        shutterMin,
        shutterMax,
        isoMin,
        isoMax,
        focalMin,
        focalMax
      };
    }

    // Apply filters
    function applyFilters() {
      const filters = getFilterState();

      filteredPhotos = allPhotosData.filter(photo => {
        // Tag filter
        let hasTag = true;
        if (filters.tags.length > 0) {
          const photoTags = photo.data.tags.map(t => normalizeTag(t)).filter(t => t);
          
          if (filters.tagLogic === 'and') {
            // AND logic: photo must have ALL selected tags
            hasTag = filters.tags.every(tag => {
              const normalizedTag = normalizeTag(tag);
              return photoTags.includes(normalizedTag);
            });
          } else {
            // OR logic: photo must have ANY selected tag (default)
            hasTag = filters.tags.some(tag => {
              const normalizedTag = normalizeTag(tag);
              return photoTags.includes(normalizedTag);
            });
          }
          
          if (!hasTag) return false;
        }

        // Album filter
        if (filters.albums.length > 0) {
          const hasAlbum = filters.albums.includes(photo.data.album);
          if (!hasAlbum) return false;
        }

        // Camera filter
        if (filters.cameras.length > 0) {
          if (!photo.data.camera || !filters.cameras.includes(photo.data.camera)) {
            return false;
          }
        }

        // Date filter
        const photoDate = new Date(photo.data.date);
        if (photoDate < filters.dateMin || photoDate > filters.dateMax) {
          return false;
        }

        // EXIF filters
        const exif = parseSettings(photo.data.settings);

        if (exif.aperture !== undefined) {
          if (exif.aperture < filters.apertureMin || exif.aperture > filters.apertureMax) {
            return false;
          }
        }

        if (exif.shutterSpeed !== undefined) {
          if (exif.shutterSpeed < filters.shutterMin || exif.shutterSpeed > filters.shutterMax) {
            return false;
          }
        }

        if (exif.iso !== undefined) {
          if (exif.iso < filters.isoMin || exif.iso > filters.isoMax) {
            return false;
          }
        }

        if (photo.data.focalLength !== undefined) {
          if (photo.data.focalLength < filters.focalMin || photo.data.focalLength > filters.focalMax) {
            return false;
          }
        }

        return true;
      });

      // Reset batch index and clear grid
      currentBatchIndex = 0;
      displayedPhotos = [];
      document.getElementById('photos-grid').innerHTML = '';

      // Update lightbox with filtered photos
      if (window.photoLightbox) {
        window.photoLightbox.updatePhotos(filteredPhotos);
      }

      // Update counts
      updateFilterCount();
      updatePhotoCount();

      // Load first batch
      loadNextBatch();
    }

    // Load next batch of photos
    function loadNextBatch() {
      const grid = document.getElementById('photos-grid');
      const loadingIndicator = document.getElementById('loading-indicator');
      const noResults = document.getElementById('no-results');

      // Hide no results message
      noResults.style.display = 'none';

      if (currentBatchIndex >= filteredPhotos.length) {
        loadingIndicator.style.display = 'none';

        // Show no results if no photos
        if (filteredPhotos.length === 0) {
          noResults.style.display = 'flex';
        }

        return;
      }

      const batch = filteredPhotos.slice(
        currentBatchIndex,
        currentBatchIndex + BATCH_SIZE
      );

      batch.forEach(photo => {
        const card = document.createElement('div');
        card.className = 'photo-card';
        card.setAttribute('data-photo-id', photo.id);

        card.innerHTML = `
          <div class="photo-image">
            <img
              src="${photo.resizedUrl}"
              alt="${photo.data.title}"
              loading="lazy"
              style="object-position: center ${photo.data.position || 'top'};"
            />
            ${viewfinderMarkup}
          </div>
        `;

        grid.appendChild(card);
        displayedPhotos.push(photo);
      });

      currentBatchIndex += BATCH_SIZE;
      updatePhotoCount();

      // Set up intersection observer for the last photo
      if (currentBatchIndex < filteredPhotos.length) {
        const lastCard = grid.lastElementChild;
        if (lastCard) {
          observeLastCard(lastCard);
        }
      }
    }

    // Intersection observer for progressive loading
    let observer;
    function observeLastCard(card) {
      if (observer) {
        observer.disconnect();
      }

      observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const loadingIndicator = document.getElementById('loading-indicator');
            loadingIndicator.style.display = 'flex';

            setTimeout(() => {
              loadNextBatch();
              loadingIndicator.style.display = 'none';
            }, 300);
          }
        });
      }, {
        rootMargin: '200px'
      });

      observer.observe(card);
    }

    // Update filter count badge
    function updateFilterCount() {
      const filters = getFilterState();
      let count = 0;

      count += filters.tags.length;
      count += filters.albums.length;
      count += filters.cameras.length;

      // Check if date range is narrowed (actually filtering)
      const dateMin = new Date(exifRangesData.date.min);
      const dateMax = new Date(exifRangesData.date.max);
      if (filters.dateMin.getTime() > dateMin.getTime() ||
          filters.dateMax.getTime() < dateMax.getTime()) {
        count++;
      }

      // Check if EXIF ranges are narrowed (actually filtering)
      // Only count if the range is narrower than the full range
      if (filters.apertureMin > exifRangesData.aperture.min ||
          filters.apertureMax < exifRangesData.aperture.max) {
        count++;
      }
      if (filters.shutterMin > exifRangesData.shutterSpeed.min ||
          filters.shutterMax < exifRangesData.shutterSpeed.max) {
        count++;
      }
      if (filters.isoMin > exifRangesData.iso.min ||
          filters.isoMax < exifRangesData.iso.max) {
        count++;
      }
      if (filters.focalMin > exifRangesData.focalLength.min ||
          filters.focalMax < exifRangesData.focalLength.max) {
        count++;
      }

      const badge = document.getElementById('filter-count');
      if (count > 0) {
        badge.textContent = count;
        badge.style.display = 'inline-flex';
      } else {
        badge.style.display = 'none';
      }
    }

    // Update photo count display
    function updatePhotoCount() {
      document.getElementById('visible-count').textContent =
        Math.min(displayedPhotos.length, filteredPhotos.length);
      document.getElementById('total-count').textContent = filteredPhotos.length;
    }

    // Clear all filters
    function clearAllFilters() {
      // Uncheck all checkboxes
      document.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);

      // Reset tag search
      const tagSearch = document.getElementById('tag-search');
      if (tagSearch) {
        tagSearch.value = '';
        // Remove search-hidden from all tag labels
        document.querySelectorAll('#tags-filter .filter-checkbox-label').forEach(label => {
          label.classList.remove('search-hidden');
        });
      }

    // Reset tag logic to OR
    setTagLogic('or');

      // Reset date range
      document.getElementById('date-min').value = exifRangesData.date.min.split('T')[0];
      document.getElementById('date-max').value = exifRangesData.date.max.split('T')[0];

      // Reset EXIF ranges
      document.getElementById('aperture-min').value = exifRangesData.aperture.min;
      document.getElementById('aperture-max').value = exifRangesData.aperture.max;
      document.getElementById('aperture-min-value').textContent = `f/${exifRangesData.aperture.min}`;
      document.getElementById('aperture-max-value').textContent = `f/${exifRangesData.aperture.max}`;

      document.getElementById('shutter-min').value = exifRangesData.shutterSpeed.min;
      document.getElementById('shutter-max').value = exifRangesData.shutterSpeed.max;
      const shutterMinFormatted = formatShutterSpeed(exifRangesData.shutterSpeed.min);
      const shutterMaxFormatted = formatShutterSpeed(exifRangesData.shutterSpeed.max);
      document.getElementById('shutter-min-value').textContent = shutterMinFormatted;
      document.getElementById('shutter-max-value').textContent = shutterMaxFormatted;

      document.getElementById('iso-min').value = exifRangesData.iso.min;
      document.getElementById('iso-max').value = exifRangesData.iso.max;
      document.getElementById('iso-min-value').textContent = exifRangesData.iso.min;
      document.getElementById('iso-max-value').textContent = exifRangesData.iso.max;

      document.getElementById('focal-min').value = exifRangesData.focalLength.min;
      document.getElementById('focal-max').value = exifRangesData.focalLength.max;
      document.getElementById('focal-min-value').textContent = `${Math.round(exifRangesData.focalLength.min)}mm`;
      document.getElementById('focal-max-value').textContent = `${Math.round(exifRangesData.focalLength.max)}mm`;

      applyFilters();

      // Reset tag availability (after filters are applied)
      document.querySelectorAll('#tags-filter .filter-checkbox-label').forEach(label => {
        label.classList.remove('unavailable');
      });
    }

    // Initialize filter panel state - collapsed by default
    const savedState = localStorage.getItem('filterPanelCollapsed');
    const panelCollapsed = savedState !== null ? savedState === 'true' : true; // Default to collapsed

    const filterPanel = document.getElementById('filter-panel');
    if (panelCollapsed) {
      filterPanel.classList.add('collapsed');
    }

    // Toggle filter panel
    document.getElementById('toggle-filters').addEventListener('click', () => {
      filterPanel.classList.toggle('collapsed');

      // Save state to localStorage
      localStorage.setItem('filterPanelCollapsed', filterPanel.classList.contains('collapsed'));
    });

    // Close filter panel
    document.getElementById('close-filters').addEventListener('click', () => {
      filterPanel.classList.add('collapsed');

      // Save state to localStorage
      localStorage.setItem('filterPanelCollapsed', 'true');
    });

    // Filter event listeners
    document.querySelectorAll('input[type="checkbox"]').forEach(cb => {
      cb.addEventListener('change', applyFilters);
    });

    document.getElementById('date-min').addEventListener('change', applyFilters);
    document.getElementById('date-max').addEventListener('change', applyFilters);

    // Range slider event listeners with live updates
    ['aperture', 'shutter', 'iso', 'focal'].forEach(type => {
      const minSlider = document.getElementById(`${type}-min`);
      const maxSlider = document.getElementById(`${type}-max`);
      const minValue = document.getElementById(`${type}-min-value`);
      const maxValue = document.getElementById(`${type}-max-value`);

      let updateTimeout;

      minSlider.addEventListener('input', () => {
        const min = parseFloat(minSlider.value);
        const max = parseFloat(maxSlider.value);

        if (min > max) {
          minSlider.value = max;
        }

        if (type === 'aperture') {
          minValue.textContent = `f/${minSlider.value}`;
        } else if (type === 'shutter') {
          minValue.textContent = formatShutterSpeed(parseFloat(minSlider.value));
        } else if (type === 'focal') {
          minValue.textContent = `${Math.round(minSlider.value)}mm`;
        } else {
          minValue.textContent = minSlider.value;
        }

        clearTimeout(updateTimeout);
        updateTimeout = setTimeout(applyFilters, 300);
      });

      maxSlider.addEventListener('input', () => {
        const min = parseFloat(minSlider.value);
        const max = parseFloat(maxSlider.value);

        if (max < min) {
          maxSlider.value = min;
        }

        if (type === 'aperture') {
          maxValue.textContent = `f/${maxSlider.value}`;
        } else if (type === 'shutter') {
          maxValue.textContent = formatShutterSpeed(parseFloat(maxSlider.value));
        } else if (type === 'focal') {
          maxValue.textContent = `${Math.round(maxSlider.value)}mm`;
        } else {
          maxValue.textContent = maxSlider.value;
        }

        clearTimeout(updateTimeout);
        updateTimeout = setTimeout(applyFilters, 300);
      });
    });

    // Tag logic toggle handlers
    const tagLogicToggle = document.getElementById('tag-logic-toggle');
    const tagSearchInput = document.getElementById('tag-search');

    // Get all tag checkbox labels
    function getTagLabels() {
      return Array.from(document.querySelectorAll('#tags-filter .filter-checkbox-label'));
    }

    // Get currently selected tags
    function getSelectedTags() {
      return Array.from(document.querySelectorAll('input[name="tag"]:checked'))
        .map(el => normalizeTag(el.value))
        .filter(t => t);
    }

    // Get current tag logic mode
    function getCurrentTagLogic() {
      const activeToggle = document.querySelector('.tag-logic-toggle .toggle-option[aria-pressed="true"]');
      return activeToggle?.getAttribute('data-mode') || 'or';
    }

    // Update tag availability in AND mode
    function updateTagAvailability() {
      const currentLogic = getCurrentTagLogic();
      const tagsContainer = document.getElementById('tags-filter');
      const labels = getTagLabels();

      if (currentLogic === 'or') {
        // In OR mode, all tags are available - restore original order by photo count
        labels.forEach(label => {
          label.classList.remove('unavailable');
        });
        // Sort by original photo count (stored in data attribute or tag-count text)
        const sorted = [...labels].sort((a, b) => {
          const countA = parseInt(a.querySelector('.tag-count')?.textContent?.replace(/[()]/g, '') || '0', 10);
          const countB = parseInt(b.querySelector('.tag-count')?.textContent?.replace(/[()]/g, '') || '0', 10);
          return countB - countA;
        });
        sorted.forEach(label => tagsContainer.appendChild(label));
        return;
      }

      // In AND mode, only show tags that would still produce results
      const selectedTags = getSelectedTags();
      const filtered = filterPhotosByTags(allPhotosData, selectedTags, 'and');
      const availableTags = getAvailableTags(allPhotosData, selectedTags, 'and');
      const filteredTagCounts = new Map();
      filtered.forEach(photo => {
        (photo.data.tags || []).forEach(tag => {
          const normalized = normalizeTag(tag);
          if (normalized) {
            filteredTagCounts.set(normalized, (filteredTagCounts.get(normalized) || 0) + 1);
          }
        });
      });

      // Update label classes and reorder: available tags first (sorted by filtered count), then unavailable
      const availableLabels = [];
      const unavailableLabels = [];

      labels.forEach(label => {
        const tag = normalizeTag(label.getAttribute('data-tag'));
        if (availableTags.has(tag)) {
          label.classList.remove('unavailable');
          availableLabels.push({ label, count: filteredTagCounts.get(tag) || 0, isSelected: selectedTags.includes(tag) });
        } else {
          label.classList.add('unavailable');
          unavailableLabels.push(label);
        }
      });

      // Sort available: selected first, then by filtered count descending
      availableLabels.sort((a, b) => {
        if (a.isSelected !== b.isSelected) return a.isSelected ? -1 : 1;
        return b.count - a.count;
      });

      // Reorder DOM: available tags first, then unavailable
      availableLabels.forEach(item => tagsContainer.appendChild(item.label));
      unavailableLabels.forEach(label => tagsContainer.appendChild(label));
    }

    // Tag search functionality
    function handleTagSearch() {
      const query = tagSearchInput.value.toLowerCase().trim();

      getTagLabels().forEach(label => {
        const tag = label.getAttribute('data-tag') || '';
        if (query === '' || tag.toLowerCase().includes(query)) {
          label.classList.remove('search-hidden');
        } else {
          label.classList.add('search-hidden');
        }
      });
    }

    tagSearchInput.addEventListener('input', handleTagSearch);

    function setTagLogic(mode) {
      const normalizedMode = mode === 'and' ? 'and' : 'or';
      const toggleButtons = tagLogicToggle?.querySelectorAll('.toggle-option') || [];
      toggleButtons.forEach(btn => {
        btn.setAttribute('aria-pressed', btn.getAttribute('data-mode') === normalizedMode ? 'true' : 'false');
      });
      applyFilters();
      updateTagAvailability();
    }

    setupTagLogicToggle(tagLogicToggle, setTagLogic);

    // Update tag availability when tags change
    document.querySelectorAll('input[name="tag"]').forEach(cb => {
      cb.addEventListener('change', () => {
        updateTagAvailability();
      });
    });

    // Clear filters button
    document.getElementById('clear-filters').addEventListener('click', clearAllFilters);
    document.getElementById('reset-filters').addEventListener('click', clearAllFilters);

    // Initial load - ensure DOM is ready and layout is settled
    requestAnimationFrame(() => {
      loadNextBatch();
      updateTagAvailability();
    });
  </script>

  <style>
    .photos-page {
      max-width: 1800px;
      width: 100%;
      margin: 0 auto;
      padding: 0 1.5rem 2rem;
    }

    .page-header {
      text-align: center;
      margin-bottom: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      position: sticky;
      top: 0;
      background: var(--cream);
      padding: 1rem 1.5rem 1rem;
      z-index: 50;
      border-bottom: 1px solid rgba(28, 25, 23, 0.1);
    }

    .page-title {
      font-family: 'Crimson Text', serif;
      font-size: 3.5rem;
      font-weight: 700;
      color: var(--charcoal);
      margin: 0;
      letter-spacing: -0.03em;
    }

    .page-subtitle {
      font-size: 1.125rem;
      color: var(--gray);
      margin: 0;
      font-weight: 400;
    }

    .toggle-filters-btn {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem 1.5rem;
      background: var(--amber);
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    .toggle-filters-btn:hover {
      background: var(--terracotta);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(194, 65, 12, 0.3);
    }

    .filter-count {
      position: absolute;
      top: -8px;
      right: -8px;
      background: var(--terracotta);
      color: white;
      font-size: 0.75rem;
      font-weight: 600;
      padding: 0.25rem 0.5rem;
      border-radius: 12px;
      min-width: 24px;
      text-align: center;
    }

    .content-wrapper {
      display: flex;
      gap: 2rem;
      align-items: start;
      position: relative;
    }

    .filter-panel {
      position: sticky;
      top: 2rem;
      background: var(--cream-dark);
      border-radius: 8px;
      padding: 1.5rem;
      max-height: calc(100vh - 4rem);
      overflow-y: auto;
      transition: width 0.3s ease, opacity 0.3s ease, padding 0.3s ease, margin 0.3s ease;
      border: 1px solid rgba(28, 25, 23, 0.1);
      width: 320px;
      flex-shrink: 0;
    }

    .filter-panel.collapsed {
      width: 0;
      opacity: 0;
      pointer-events: none;
      padding: 0;
      margin: 0;
      border: none;
      overflow: hidden;
    }

    .filter-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 2px solid var(--amber);
    }

    .filter-panel-title {
      font-family: 'Crimson Text', serif;
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--charcoal);
      margin: 0;
    }

    .filter-header-actions {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .clear-filters-btn {
      background: none;
      border: none;
      color: var(--amber);
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .clear-filters-btn:hover {
      background: rgba(245, 158, 11, 0.1);
      color: var(--terracotta);
    }

    .close-filters-btn {
      background: none;
      border: none;
      color: var(--gray);
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 4px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
    }

    .close-filters-btn:hover {
      background: rgba(28, 25, 23, 0.1);
      color: var(--charcoal);
    }

    .close-filters-btn svg {
      width: 20px;
      height: 20px;
    }

    .filter-sections {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .filter-section {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .filter-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
    }

    .filter-section-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--charcoal);
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .tag-logic-toggle {
      display: flex;
      background: rgba(28, 25, 23, 0.05);
      border-radius: 20px;
      padding: 2px;
      gap: 2px;
    }

    .tag-logic-toggle .toggle-option {
      padding: 0.25rem 0.75rem;
      border: none;
      background: transparent;
      color: var(--gray);
      font-size: 0.75rem;
      font-weight: 600;
      cursor: pointer;
      border-radius: 18px;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .tag-logic-toggle .toggle-option:hover {
      color: var(--charcoal);
    }

    .tag-logic-toggle .toggle-option[aria-pressed="true"] {
      background: var(--amber);
      color: white;
    }

    .tag-search-wrapper {
      position: relative;
      margin-bottom: 0.75rem;
    }

    .tag-search-input {
      width: 100%;
      padding: 0.5rem 0.75rem 0.5rem 2rem;
      border: 1px solid rgba(28, 25, 23, 0.2);
      border-radius: 4px;
      font-size: 0.875rem;
      background: white;
      color: var(--charcoal);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .tag-search-input:focus {
      outline: none;
      border-color: var(--amber);
      box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.2);
    }

    .tag-search-input::placeholder {
      color: var(--gray);
    }

    .tag-search-icon {
      position: absolute;
      left: 0.5rem;
      top: 50%;
      transform: translateY(-50%);
      color: var(--gray);
      pointer-events: none;
    }

    .filter-checkboxes {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      max-height: 200px;
      overflow-y: auto;
      padding-right: 0.5rem;
    }

    .filter-checkbox-label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      font-size: 0.875rem;
      color: var(--charcoal);
      transition: color 0.2s ease;
    }

    .filter-checkbox-label:hover {
      color: var(--amber);
    }

    .filter-checkbox-label input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
      accent-color: var(--amber);
      flex-shrink: 0;
    }

    .filter-checkbox-label .tag-name {
      flex: 1;
      min-width: 0;
    }

    .filter-checkbox-label .tag-count {
      font-size: 0.75rem;
      color: var(--gray);
      font-weight: 400;
      flex-shrink: 0;
    }

    .filter-checkbox-label.unavailable {
      opacity: 0.4;
      pointer-events: none;
    }

    .filter-checkbox-label.search-hidden {
      display: none !important;
    }

    .filter-range-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }

    .filter-input-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .filter-input-group label {
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--gray);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .filter-input-group input[type="date"] {
      padding: 0.5rem;
      border: 1px solid rgba(28, 25, 23, 0.2);
      border-radius: 4px;
      font-size: 0.875rem;
      background: white;
      color: var(--charcoal);
    }

    .filter-range-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .filter-range-slider {
      position: relative;
      height: 40px;
    }

    .filter-range-slider input[type="range"] {
      position: absolute;
      width: 100%;
      height: 4px;
      background: transparent;
      pointer-events: none;
      -webkit-appearance: none;
    }

    .filter-range-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      pointer-events: all;
      width: 16px;
      height: 16px;
      background: var(--amber);
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .filter-range-slider input[type="range"]::-moz-range-thumb {
      pointer-events: all;
      width: 16px;
      height: 16px;
      background: var(--amber);
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .filter-range-slider input[type="range"]:first-child {
      z-index: 1;
    }

    .filter-range-slider::before {
      content: '';
      position: absolute;
      top: 18px;
      left: 0;
      right: 0;
      height: 4px;
      background: rgba(28, 25, 23, 0.2);
      border-radius: 2px;
    }

    .filter-range-values {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--charcoal);
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
    }

    .photos-main {
      min-height: 600px;
      flex: 1;
      width: 100%;
    }

    .photos-status {
      text-align: center;
      margin-bottom: 1.5rem;
      font-size: 0.875rem;
      color: var(--gray);
      font-weight: 500;
    }

    .photos-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2rem;
    }

    /* Photo card styles imported via PhotoLayout from photo-card.css */

    .loading-indicator {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 3rem;
      gap: 1rem;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(28, 25, 23, 0.1);
      border-top-color: var(--amber);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-indicator p {
      color: var(--gray);
      font-size: 0.875rem;
      margin: 0;
    }

    .no-results {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 4rem 2rem;
      text-align: center;
      gap: 1.5rem;
    }

    .no-results p {
      font-size: 1.125rem;
      color: var(--gray);
      margin: 0;
    }

    .reset-filters-btn {
      padding: 0.75rem 1.5rem;
      background: var(--amber);
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .reset-filters-btn:hover {
      background: var(--terracotta);
      transform: translateY(-2px);
    }

    @media (max-width: 1024px) {
      .content-wrapper {
        flex-direction: column;
      }

      .filter-panel {
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        z-index: 1000;
        max-height: 100vh;
        border-radius: 0;
        width: 320px;
        box-shadow: 4px 0 12px rgba(0, 0, 0, 0.1);
      }

      .filter-panel.collapsed {
        transform: translateX(-100%);
        width: 0;
        padding: 0;
        border: none;
        overflow: hidden;
      }

      .toggle-filters-btn {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        z-index: 100;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        border-radius: 50%;
        width: 60px;
        height: 60px;
        padding: 0;
        justify-content: center;
      }

      .toggle-filters-btn span:not(.filter-count) {
        display: none;
      }

      .toggle-filters-btn svg {
        margin: 0;
      }
    }

    @media (max-width: 768px) {
      .page-title {
        font-size: 2rem;
      }

      .page-subtitle {
        font-size: 0.875rem;
      }

      .page-header {
        padding: 1.5rem 1rem 1rem;
      }

      .photos-grid {
        grid-template-columns: 1fr;
        gap: 1.5rem;
      }

      .filter-panel {
        width: 100%;
        max-width: 320px;
      }

      .toggle-filters-btn {
        width: 56px;
        height: 56px;
        bottom: 1.5rem;
        right: 1.5rem;
      }
    }
  </style>
</PhotoLayout>
