---
import PhotoLayout from "../../../layouts/PhotoLayout.astro";
import { getPhotosWithExif, sortPhotos, extractTags, extractTagNames, transformForLightbox } from "../../../utils/photo-helpers";
import { getPhotoUrl } from "../../../utils/url-helper";
import PhotoLightbox from "../../../components/photo/PhotoLightbox.astro";
import TagFilterBar from "../../../components/photo/TagFilterBar.astro";
import { getCollection } from "astro:content";
import { FilteredPhotoGallery } from "../../../components/react/FilteredPhotoGallery";

export async function getStaticPaths() {
  const allPhotos = await getPhotosWithExif();

  // Collect all unique tags (preserving original casing for URLs)
  const tagsWithDisplay = extractTags(allPhotos, { preserveDisplayCasing: true });

  // Return paths for each unique tag (Astro handles URL encoding automatically)
  return tagsWithDisplay.map(({ displayTag }) => ({
    params: { tag: displayTag },
  }));
}

const { tag } = Astro.params;
const decodedTag = decodeURIComponent(tag || "");

const albums = await getCollection("albums");
const albumTitleMap = new Map(albums.map((a) => [a.slug, a.data.title]));

const allPhotos = sortPhotos(await getPhotosWithExif());

// Get all unique tags for the filter pills (sorted alphabetically)
const allTags = extractTagNames(allPhotos, 'alpha');

const filteredPhotos = allPhotos.filter((photo) =>
  photo.data.tags.some((t) => t.toLowerCase() === decodedTag.toLowerCase()),
);
const sortedPhotos = sortPhotos(filteredPhotos);
---

<PhotoLayout
  title={`${decodedTag} Photos`}
  description={`Photos tagged with ${decodedTag}`}
>
  <div class="tag-page">
    <div class="tag-header">
      <h1 class="tag-title">#{decodedTag.toLowerCase()}</h1>
      <p class="tag-count" id="photo-count">
        {sortedPhotos.length}
        {sortedPhotos.length === 1 ? "photo" : "photos"}
      </p>
    </div>

    <!-- Tag Filter Pills -->
    <TagFilterBar tags={allTags} initialActiveTag={decodedTag.toLowerCase()} />

    {
      sortedPhotos.length === 0 ? (
        <p class="no-photos">No photos found with this tag.</p>
      ) : (
        <>
          <div class="gallery-container">
            <FilteredPhotoGallery
              client:load
              allPhotos={allPhotos.map((p) => ({
                ...p,
                data: {
                  ...p.data,
                  albumTitle: albumTitleMap.get(p.data.album),
                  date: p.data.date.toISOString(),
                  position: p.data.position,
                },
              }))}
              initialActiveTags={[decodedTag.toLowerCase()]}
            />
          </div>
          <PhotoLightbox
            photos={sortedPhotos.map((p) => transformForLightbox(p, albumTitleMap))}
          />
        </>
      )
    }
  </div>

  <style>
    .tag-page {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem 1.5rem;
      display: flex;
      flex-direction: column;
      min-height: 0; /* Allow flex child to shrink */
    }

    .tag-header {
      text-align: center;
      margin-bottom: 2rem;
      padding-bottom: 2rem;
      border-bottom: 1px solid rgba(28, 25, 23, 0.1);
    }

    .tag-title {
      font-family: "Crimson Text", serif;
      font-size: 3.5rem;
      font-weight: 700;
      color: var(--charcoal);
      margin: 0 0 0.5rem;
      letter-spacing: -0.02em;
    }

    .tag-count {
      color: var(--gray);
      font-size: 1rem;
      font-weight: 400;
    }

    .no-photos {
      text-align: center;
      color: var(--gray);
      font-size: 1.125rem;
      padding: 4rem 2rem;
    }

    .gallery-container {
      margin-top: 2rem;
      flex: 1;
      min-height: 0; /* Allow flex child to shrink */
    }

    /* Photo card base styles imported via PhotoLayout from photo-card.css */
    /* Overrides for virtualized grid (React Window positions absolutely) */
    :global(.photo-card) {
      position: absolute;
    }

    :global(.photo-card:hover) {
      z-index: 10; /* Ensure hovered item is above */
    }

    :global(.photo-image) {
      height: 100%; /* Override aspect-ratio for virtualized grid */
    }

    @media (max-width: 768px) {
      .tag-page {
        padding: 1.5rem 1rem;
      }

      .tag-title {
        font-size: 2.5rem;
      }

      .gallery-container {
        margin-top: 1.5rem;
      }
    }
  </style>

  <script>
    import { filterPhotosByTags, getAvailableTags, normalizeTag, setupTagLogicToggle } from '../../../utils/client/tag-utils';
    (window as any).photoTagUtils = { filterPhotosByTags, getAvailableTags, normalizeTag, setupTagLogicToggle };
  </script>

  <script
    define:vars={{
      allPhotosData: allPhotos.map((p) => ({
        id: p.id,
        url: getPhotoUrl(p.data.filename),
        data: {
          title: p.data.title,
          filename: p.data.filename,
          album: p.data.album,
          albumTitle: albumTitleMap.get(p.data.album),
          tags: (p.data.tags || [])
            .map((t) => (t || "").trim())
            .filter((t) => t),
          camera: p.data.camera,
          settings: p.data.settings,
          focalLength: p.data.focalLength,
          location: p.data.location,
          position: p.data.position,
        },
      })),
    }}
  >
    const normalizeTag =
      (window.photoTagUtils && window.photoTagUtils.normalizeTag) ||
      ((tag) =>
        String(tag ?? "")
          .toLowerCase()
          .trim());

    const filterPhotosByTags =
      (window.photoTagUtils && window.photoTagUtils.filterPhotosByTags) ||
      ((photos, tags, logic = "or") => {
        if (tags.length === 0) {
          return photos;
        }

        return photos.filter((photo) => {
          const photoTags = (photo.data?.tags || [])
            .map((t) => normalizeTag(t))
            .filter(Boolean);

          if (logic === "and") {
            return tags.every((tag) => photoTags.includes(normalizeTag(tag)));
          }

          return tags.some((tag) => photoTags.includes(normalizeTag(tag)));
        });
      });

    const getAvailableTags =
      (window.photoTagUtils && window.photoTagUtils.getAvailableTags) ||
      ((photos, selectedTags, logic) => {
        if (logic === "or") {
          const allTags = new Set();
          photos.forEach((photo) => {
            (photo.data?.tags || []).forEach((tag) => {
              const normalized = normalizeTag(tag);
              if (normalized) {
                allTags.add(normalized);
              }
            });
          });
          return allTags;
        }

        const filtered = filterPhotosByTags(photos, selectedTags, "and");
        const available = new Set();

        filtered.forEach((photo) => {
          (photo.data?.tags || []).forEach((tag) => {
            const normalized = normalizeTag(tag);
            if (normalized) {
              available.add(normalized);
            }
          });
        });

        selectedTags.forEach((tag) => available.add(normalizeTag(tag)));
        return available;
      });

    document.addEventListener("DOMContentLoaded", () => {
      const getTagPills = () =>
        Array.from(document.querySelectorAll(".tag-pill"));
      const photoCount = document.getElementById("photo-count");
      const clearFiltersBtn = document.getElementById("clear-filters");
      const filterToggle = document.getElementById("filter-toggle");
      const tagPillsContainer = document.getElementById("tag-pills-container");
      const tagLogicToggle = document.getElementById("tag-logic-toggle");
      const tagTitle = document.querySelector(".tag-title");
      const initialTag = document
        .querySelector(".tag-pill.active")
        ?.getAttribute("data-tag");
      const initialTitle = tagTitle?.textContent || "";
      let currentTagLogic = "or";

      const photoDataset = Array.isArray(allPhotosData) ? allPhotosData : [];

      const getRawActiveTags = () =>
        getTagPills()
          .filter((pill) => pill.classList.contains("active"))
          .map((pill) => pill.getAttribute("data-tag") || "")
          .filter(Boolean);

      const dispatchFilterChange = () => {
        const normalized = getRawActiveTags().map((tag) => normalizeTag(tag));
        window.dispatchEvent(
          new CustomEvent("tagFilterChange", {
            detail: {
              activeTags: normalized,
              tagLogic: currentTagLogic,
            },
          }),
        );
      };

      const updateTagAvailability = () => {
        if (currentTagLogic === "or") {
          getTagPills().forEach((pill) => {
            pill.style.display = "";
          });
          return;
        }

        const normalizedActiveTags = getRawActiveTags().map((tag) =>
          normalizeTag(tag),
        );
        const filtered = filterPhotosByTags(photoDataset, normalizedActiveTags, "and");
        const available = getAvailableTags(photoDataset, normalizedActiveTags, "and");

        getTagPills().forEach((pill) => {
          const normalized = normalizeTag(pill.getAttribute("data-tag"));
          pill.style.display = available.has(normalized) ? "" : "none";
        });
      };

      // Update lightbox when filters change - will be called by React component
      window.updateLightboxFromFilter = function (filteredPhotos) {
        if (!window.photoLightbox) return;
        window.photoLightbox.updatePhotos(filteredPhotos);

        // Update count
        if (photoCount) {
          photoCount.textContent = `${filteredPhotos.length} ${filteredPhotos.length === 1 ? "photo" : "photos"}`;
        }
      };

      // Toggle filter bar
      filterToggle?.addEventListener("click", () => {
        filterToggle.classList.toggle("expanded");
        tagPillsContainer?.classList.toggle("expanded");
      });

      // Handle tag logic toggle using shared utility
      const setupToggle = window.photoTagUtils?.setupTagLogicToggle;
      if (setupToggle && tagLogicToggle) {
        setupToggle(tagLogicToggle, (mode) => {
          if (mode === currentTagLogic) return;
          currentTagLogic = mode;
          dispatchFilterChange();
          updateTagAvailability();
        });
      }

      const updateUiAfterSelection = () => {
        const activeTags = getRawActiveTags();

        if (tagTitle) {
          if (activeTags.length > 1) {
            const sortedTags = [...activeTags].sort();
            tagTitle.textContent = sortedTags.map((t) => `#${t}`).join(" + ");
          } else if (activeTags.length === 1) {
            tagTitle.textContent = `#${activeTags[0]}`;
          } else {
            tagTitle.textContent = initialTitle;
          }
        }

        if (clearFiltersBtn) {
          clearFiltersBtn.style.display =
            activeTags.length > 1 ? "block" : "none";
        }
      };

      // Tag pill click handler - will trigger React component update
      getTagPills().forEach((pill) => {
        pill.addEventListener("click", () => {
          const isActive = pill.classList.contains("active");

          if (isActive) {
            const activeCount =
              document.querySelectorAll(".tag-pill.active").length;
            if (activeCount > 1) {
              pill.classList.remove("active");
              dispatchFilterChange();
            }
          } else {
            pill.classList.add("active");
            dispatchFilterChange();
          }

          updateUiAfterSelection();
          updateTagAvailability();
        });
      });

      // Clear filters handler
      if (clearFiltersBtn) {
        clearFiltersBtn.addEventListener("click", () => {
          getTagPills().forEach((pill) => {
            const tag = pill.getAttribute("data-tag");
            if (tag === initialTag) {
              pill.classList.add("active");
            } else {
              pill.classList.remove("active");
            }
          });

          dispatchFilterChange();

          if (tagTitle) {
            tagTitle.textContent = initialTitle;
          }
          clearFiltersBtn.style.display = "none";
          updateTagAvailability();
        });
      }

      // Initialize UI
      updateUiAfterSelection();
      updateTagAvailability();
    });
  </script>
</PhotoLayout>
